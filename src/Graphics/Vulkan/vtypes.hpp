#ifndef __VTYPES__
#define __VTYPES__

#include <vulkan/vulkan.h>
#include <vk_mem_alloc.h>
#include <iostream>
#include <vector>
#include <map>
#include "Debug/debug.hpp"



namespace vtypes {
    const inline std::map<VkResult, std::string> results = {
            { VK_SUCCESS, "SUCCESS" },
            { VK_NOT_READY, "NOT_READY" },
            { VK_TIMEOUT, "TIMEOUT" },
            { VK_EVENT_SET, "EVENT_SET" },
            { VK_EVENT_RESET, "EVENT_RESET" },
            { VK_INCOMPLETE, "INCOMPLETE" },
            { VK_ERROR_OUT_OF_HOST_MEMORY, "ERROR_OUT_OF_HOST_MEMORY" },
            { VK_ERROR_OUT_OF_DEVICE_MEMORY, "ERROR_OUT_OF_DEVICE_MEMORY" },
            { VK_ERROR_INITIALIZATION_FAILED, "ERROR_INITIALIZATION_FAILED" },
            { VK_ERROR_DEVICE_LOST, "ERROR_DEVICE_LOST" },
            { VK_ERROR_MEMORY_MAP_FAILED, "ERROR_MEMORY_MAP_FAILED" },
            { VK_ERROR_LAYER_NOT_PRESENT, "ERROR_LAYER_NOT_PRESENT" },
            { VK_ERROR_EXTENSION_NOT_PRESENT, "ERROR_EXTENSION_NOT_PRESENT" },
            { VK_ERROR_FEATURE_NOT_PRESENT, "ERROR_FEATURE_NOT_PRESENT" },
            { VK_ERROR_INCOMPATIBLE_DRIVER, "ERROR_INCOMPATIBLE_DRIVER" },
            { VK_ERROR_TOO_MANY_OBJECTS, "ERROR_TOO_MANY_OBJECTS" },
            { VK_ERROR_FORMAT_NOT_SUPPORTED, "ERROR_FORMAT_NOT_SUPPORTED" },
            { VK_ERROR_FRAGMENTED_POOL, "ERROR_FRAGMENTED_POOL" },
            { VK_ERROR_UNKNOWN, "ERROR_UNKNOWN" },
            { VK_ERROR_OUT_OF_POOL_MEMORY, "ERROR_OUT_OF_POOL_MEMORY" },
            { VK_ERROR_INVALID_EXTERNAL_HANDLE, "ERROR_INVALID_EXTERNAL_HANDLE" },
            { VK_ERROR_FRAGMENTATION, "ERROR_FRAGMENTATION" },
            { VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS, "ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS" },
            { VK_ERROR_SURFACE_LOST_KHR, "ERROR_SURFACE_LOST_KHR" },
            { VK_ERROR_NATIVE_WINDOW_IN_USE_KHR, "ERROR_NATIVE_WINDOW_IN_USE_KHR" },
            { VK_SUBOPTIMAL_KHR, "SUBOPTIMAL_KHR" },
            { VK_ERROR_OUT_OF_DATE_KHR, "ERROR_OUT_OF_DATE_KHR" },
            { VK_ERROR_INCOMPATIBLE_DISPLAY_KHR, "ERROR_INCOMPATIBLE_DISPLAY_KHR" },
            { VK_ERROR_VALIDATION_FAILED_EXT, "ERROR_VALIDATION_FAILED_EXT" },
            { VK_ERROR_INVALID_SHADER_NV, "ERROR_INVALID_SHADER_NV" },
            { VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT, "ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT" },
            { VK_ERROR_NOT_PERMITTED_EXT, "ERROR_NOT_PERMITTED_EXT" },
            { VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT, "ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT" },
            { VK_THREAD_IDLE_KHR, "THREAD_IDLE_KHR" },
            { VK_THREAD_DONE_KHR, "THREAD_DONE_KHR" },
            { VK_OPERATION_DEFERRED_KHR, "OPERATION_DEFERRED_KHR" },
            { VK_OPERATION_NOT_DEFERRED_KHR, "OPERATION_NOT_DEFERRED_KHR" },
            { VK_PIPELINE_COMPILE_REQUIRED_EXT, "PIPELINE_COMPILE_REQUIRED_EXT" },
            { VK_ERROR_OUT_OF_POOL_MEMORY_KHR, "ERROR_OUT_OF_POOL_MEMORY_KHR" },
            { VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR, "ERROR_INVALID_EXTERNAL_HANDLE_KHR" },
            { VK_ERROR_FRAGMENTATION_EXT, "ERROR_FRAGMENTATION_EXT" },
            { VK_ERROR_INVALID_DEVICE_ADDRESS_EXT, "ERROR_INVALID_DEVICE_ADDRESS_EXT" },
            { VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR, "ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR" },
            { VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT, "ERROR_PIPELINE_COMPILE_REQUIRED_EXT" },
            { VK_RESULT_MAX_ENUM, "RESULT_MAX_ENUM" }
    };
}

#define VK_CHECK(x) do { VkResult err = x; if (err) { debug::error("Detected Vulkan error: " + vtypes::results.find(err)->second);  abort(); } } while (0)

struct VertexInputDescription {

    std::vector<VkVertexInputBindingDescription> bindings;
    std::vector<VkVertexInputAttributeDescription> attributes;

    VkPipelineVertexInputStateCreateFlags flags = 0;
};

#endif